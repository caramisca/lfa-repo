# Laboratory 5: Chomsky Normal Form

### Course: Formal Languages & Finite Automata
### Teachers: Cretu Dumitru and cudos to the Vasile Drumea with Irina Cojuhari
### Author: Caraman Mihai, FAF 233
## 1. Introduction

In this lab, I implemented a converter that takes any context-free grammar (CFG) and transforms it into **Chomsky Normal Form** (CNF). CNF is a restricted form of CFG where every production rule is one of:

* $A \to BC$ where $B,C$ are non-terminals, or
* $A \to a$ where $a$ is a terminal, or
* Optionally, $S \to \varepsilon$ if the start symbol $S$ generates the empty string.

Converting to CNF enables efficient parsing algorithms (e.g., the CYK algorithm) and theoretical proofs (e.g., closure properties, decidability bounds).

---

## 2. Theory of CNF Conversion

A standard algorithm to convert any CFG into an equivalent CNF grammar comprises five main steps:

1. **Eliminate ε-productions**: Remove productions of the form $A \to \varepsilon$ (except possibly for the start symbol).
2. **Eliminate unit productions**: Remove rules $A \to B$ where $A,B$ are non-terminals, by redirecting $A$ to all of $B$'s non-unit productions.
3. **Remove inaccessible symbols**: Discard symbols (and their productions) not reachable from the start symbol.
4. **Remove non-productive symbols**: Discard symbols that cannot derive any terminal string.
5. **Binarize and replace terminals**:

    * Any production with more than two symbols on the RHS is broken into binary rules by introducing new intermediate non-terminals (e.g., $X_1,X_2,\dots$).
    * Any terminal in a rule of length greater than one is replaced by a freshly introduced non-terminal wrapper (e.g., $T_a \to a$).

Each step preserves the language generated by the grammar (modulo the empty-string exception for the start symbol).

---

## 3. Java Implementation Overview

All core logic resides in the class `Grammar` (file: `Grammar.java`). The key fields are:

```java
private Set<String> nonTerminals;
private Set<String> terminals;
private Map<String, List<List<String>>> productions;
private String startSymbol;
```

* **nonTerminals**: set of all variable symbols (e.g., `S`, `A`, `B`).
* **terminals**: set of terminal symbols (e.g., `a`, `d`).
* **productions**: map from each non-terminal to a list of right-hand sides, each RHS being a `List<String>` of symbols.
* **startSymbol**: the distinguished start symbol `S`.

Instantiation and deep-copy of the input grammar happen in the constructor:

```java
public Grammar(Set<String> Vn, Set<String> Vt,
               Map<String,List<List<String>>> P, String S) {
    this.nonTerminals = new HashSet<>(Vn);
    this.terminals    = new HashSet<>(Vt);
    this.productions  = new HashMap<>();
    // deep-copy each RHS list...
}
```

---

## 4. Method-by-Method Explanation

Below is a summary of each private helper method in `Grammar`:

### 4.1 `eliminateEpsilonProductions()`

```java
private void eliminateEpsilonProductions() { ... }
```

* **Purpose**: Identify and remove nullable non-terminals $A$ where $A \to^* \varepsilon$.
* **Approach**:

    1. Compute the set `nullable` by fixpoint: any $A$ with a production whose RHS consists solely of nullable symbols (or `ε`) is added.
    2. For each production $A\to X_1...X_k$, generate all variants of RHS by optionally omitting nullable $X_i$.
    3. Replace any empty RHS with a single `ε` production.

### 4.2 `eliminateUnitProductions()`

```java
private void eliminateUnitProductions() { ... }
```

* **Purpose**: Remove productions of the form $A \to B$ where both sides are non-terminals.
* **Approach**:

    1. Build a directed “unit graph” where $A\to B$ creates an edge `A→B`.
    2. Compute its transitive closure so each `A` knows all `B` reachable by unit edges.
    3. For each `A`, collect all non-unit productions of itself and of each reachable `B`.

### 4.3 `eliminateInaccessibleSymbols()`

```java
private void eliminateInaccessibleSymbols() { ... }
```

* **Purpose**: Discard any non-terminals never reachable from the start symbol.
* **Approach**: Standard DFS/BFS from `startSymbol` over production‑edges.

### 4.4 `eliminateNonProductiveSymbols()`

```java
private void eliminateNonProductiveSymbols() { ... }
```

* **Purpose**: Remove non-terminals that cannot derive a terminal string.
* **Approach**: Another fixpoint: any `A` whose RHS consists entirely of terminals or already-known productive symbols is added to `productive`; then prune all others.

### 4.5 `toChomskyNormalForm()`

```java
private void toChomskyNormalForm() { ... }
```

* **Purpose**: Final CNF restructuring:

    * **Terminal wrapping**: For each terminal `t`, introduce `T_t → t`.
    * **Binarization**: Any RHS of length >2 gets split into binary rules by adding fresh symbols `X1,X2,...`.
* **Outcome**: Every remaining production is either `A→BC` or `A→t`.

---

## 5. Demonstration & Output

The `main(String[])` method sets up your **Variant 3** grammar:

```java
Vn = {S, A, B, C, E}
Vt = {a, d}
P:
  S → d B
  S → A
  A → d
  A → d S
  A → a A d A B
  B → a C
  B → a S
  B → A C
  C → ε
  E → A S
```

After calling `normalizeToCNF()`, the output printed is:

```
Original:
Start: S
N: [S, A, B, C, E]
T: [a, d]
P:  (list of original productions)

CNF:
Start: S
N: [S, A, B, C, E, T_a, T_d, X1, X2, …]
T: [a, d]
P:  (only A→BC or A→t rules)  
```

You’ll notice:

* **Wrapper non-terminals** `T_a`, `T_d` replace `a`, `d` in any binary rule.
* **Fresh variables** `X1, X2, …` ensure all productions have at most 2 symbols on the RHS.

---

## 6. Conclusions

* We’ve built a reusable `Grammar` class that can normalize *any* CFG to CNF.
* Each transformation step is clearly separated and preserves language equivalence.
* The approach scales: adding new grammars simply means creating a new `Grammar(…)` instance.

**Next steps** could include:

* Integrating a CYK parser to recognize membership of strings.
* Extending to allow the empty string only when originally in the language.

---


## References

1. **Stephen Cole Kleene (1951).** *Representation of Events in Nerve Nets and Finite Automata.*
2. **Formal Languages and Finite Automata,** Guide for Practical Lessons.
3. **Regular Expressions on Wikipedia:** [https://en.wikipedia.org/wiki/Regular_expression](https://en.wikipedia.org/wiki/Regular_expression)

